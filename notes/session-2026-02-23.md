# Session Notes — Feb 23, 2026

## What We Did

Completed the first three architecture tasks of Phase 1 from the technical roadmap: World class abstraction, block type registry, and texture array pipeline.

### 1. World Class Abstraction

**Problem:** Block data was a raw `Block[][][]` array passed directly to every consumer (greedy mesher, collision, physics) alongside `dims` and `blockSize`. This couples every system to the internal storage format, making the future transition to cubic chunks a full rewrite.

**Solution:** Created a `World` class (`src/world.ts`) that centralizes all block access:
- `getBlock(x, y, z)` — returns block data (or AIR for out-of-bounds)
- `setBlock(x, y, z, id)` — writes a block
- `isSolid(x, y, z)` — convenience check via the block registry

Refactored `greedy-mesh.ts`, `collision.ts`, `movement.ts`, and `main.ts` to pass `World` instead of raw arrays. Consumers no longer know or care how blocks are stored internally.

**Why it matters:** When cubic chunks arrive (Phase 2), the `World` class internals change (single array → chunk lookup) but every consumer's code stays identical. Zero-cost future-proofing.

### 2. Block Type Registry

**Problem:** Blocks were class instances (`new Block("DIRT")`) with string-based type checking. Object-per-block overhead, no extensibility for block properties, and the greedy mesher couldn't distinguish block types during face merging.

**Solution:** Complete rewrite of the block system (`src/block.ts`):
- `BlockId` = numeric type (`AIR = 0`, `DIRT = 1`)
- `BlockRegistry` class maps ID → `{ name, solid }` properties (extensible for `transparent`, `emissive`, `breakable`, etc.)
- `World` now stores a flat `Uint8Array` (single contiguous buffer, index formula: `y * sizeZ * sizeX + z * sizeX + x`)
- Greedy mesher encodes block type in the mask: `direction * (1 + aoPacked + (blockType << 8))`. Faces only merge when direction, AO, AND block type all match.

**Why it matters:** Adding a new block type is now: register it in `block.ts`, done. The mesher, renderer, and collision system handle it automatically. The flat `Uint8Array` is also significantly more memory-efficient than nested arrays of objects, and maps naturally to future chunk storage.

### 3. Texture Array Pipeline

**Problem:** One 2D texture (`MarbleBase1024.png`) used for all block faces. No way to give different block types different appearances.

**Solution:** Switched from `texture_2d` to `texture_2d_array` — each 256x256 layer corresponds to a block type (block ID = layer index):
- Repurposed the vertex `color` attribute (offset 36, was `unorm8x4`) → `texLayer` (`uint32`). Vertex format stays 10 floats / 40 bytes, so the wireframe shader is unaffected.
- Shader samples with `textureSample(myTexture, mySampler, uv, texLayer)`.
- Texture loading creates the array, fetches images in parallel, resizes to 256x256 via `createImageBitmap`, and copies each into its layer.
- Tiling UVs from the greedy mesher work unchanged — each layer has independent `repeat` wrapping.

**Why we chose texture array over atlas:** The greedy mesher produces world-aligned UVs that tile via `repeat` wrapping mode. An atlas would break this (can't `repeat` a sub-region of a larger image without shader hacks and mipmap bleeding issues). Texture arrays give each layer independent wrapping — zero UV math changes needed.

**Why it matters:** Adding a new block texture is now: add an entry to `blockTextureSources` in `main.ts` with a layer index and image path. The pipeline handles the rest.

## What's Next

The remaining Phase 1 tasks are the gameplay items:
1. **Raycasting** — determining which block the player is looking at
2. **Block placement/destruction** — the core mechanic
3. **BP system** — resource management

These are where the game starts becoming a game rather than an engine demo.

## Files Changed

| File | Change |
|------|--------|
| `src/block.ts` | New: numeric BlockId, BlockRegistry, AIR/DIRT constants (renamed from Block.ts) |
| `src/block-builder.ts` | Returns flat `Uint8Array` with numeric IDs |
| `src/world.ts` | New: World class with flat Uint8Array storage |
| `src/greedy-mesh.ts` | Takes World, block-type-aware merging, writes texLayer as u32 |
| `src/collision.ts` | Takes World instead of raw arrays |
| `src/movement.ts` | Takes World instead of raw arrays |
| `src/shader.ts` | `texture_2d_array`, `texLayer: u32` attribute, flat interpolation |
| `src/main.ts` | World creation, texture array loading, uint32 vertex format |
